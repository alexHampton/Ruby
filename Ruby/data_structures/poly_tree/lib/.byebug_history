n
current_node.value
queue.count
n
queue[2].value
queue[1].value
queue.first.value
queue.count
n
queue.count
current_node.value
var local
n
queue[1].value
queue[0].value
queue.count
var local
n
var local
n
current_node.value
var local
n
s
var local
n
var local
self.value
self
s
n
var local
s
queue.first.value
queue.count
var local
n
var local
n
self.value
self
q
n
self.children.count
self.children[0].value
self.children.[0].value
self.children
self.value
self
n
target_value
self.value
s
child.value
self.value
s
self.value
s
self.children
child
n
self.value
s
self.value
child.value
child
s
n
self.value
n
child.value
child
s
n
self.value
n
self.value
self
    end
        child_node.parent = nil
ild_node)
    def remove_child(child_node)
    end
        child_node.parent = self
    def add_child(child_node)
    end
        @children
def children
    end
        end
            @parent.children.push(self)
        if @parent != nil
        @parent = parent_node
        end
            @parent.children.reject! { |child| child == self }
        if @parent != nil
    def parent=(parent_node)
    end
        @parent
    def parent
    end
        @children = []
        @parent = nil
        @value = value
    def initialize(value)
    attr_reader :value
class PolyTreeNode
require 'byebug'
n
s
target_value
self.value
s
self.value
child.value
s
n
var local
self.value
self
s
child.value
self.value
self
child
s
n
var local
n
self.value
self
s
child.value
child
s
n
var local
self.value
self
n
s
self.value
child.value
var local
var all
var args
var child
var
child
h
child
s
self.children[1].value
self.children[0].value
self.children.each {|c| puts c.value}
self.children
s
target_value
self.value
self
quit
child
self
s
self.value
target_value
self
s
self
child
s
n
self
s
child
s
n
self
s
child
s
target_value
v target_value
self
